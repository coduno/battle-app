<link rel="import" href="/bower_components/iron-ajax/iron-ajax.html">
<link rel="import" href="/bower_components/paper-material/paper-material.html">
<link rel="import" href="/elements/ws-element.html">
<link rel="import" href="/elements/battle/player-service.html">

<dom-module id="battle-view">
	<style>
		paper-material {
			background: white;
			margin: 16px;
			padding: 16px;
		}
	</style>
	<template>
		<player-service id="playerService"></player-service>
		<ws-element url="{{wsUrl}}"></ws-element>
		<paper-material elevation="1" class="horizontal layout">
			<div id="battleView" style="display: inline-block;" onscroll="foo">
			</div>
			<div class="flex" style="overflow: auto;">
				<p>Battle info</p>
				<template is="dom-repeat" items="{{players}}">
					<p>{{item.nick}}<span> - hp: </span>{{item.hp}}</p>
				</template>
			</div>
		</paper-material>
	</template>
	<script src="/bower_components/pixi.js/bin/pixi.js"></script>
	<script>
		Polymer({
			is: 'battle-view',
			properties: {
				ground: Object,
				enemy: Object,
				me: Object,
				animatedPlayer: {
					type: Object,
					value: {
					}
				},
				players: {
					type: Array
				},
				currentScale: {
					type: Number,
					value: 1
				},
				nick: {
					type: String,
					value: localStorage.username
				}
			},
			listeners: {
				'ws-onerror': 'onWsError',
				'ws-onmessage': 'onWsMessage',
				'ws-onopen': 'onWsOpen'
			},
			attack: function(){
				this.animatedPlayer.attack();
			},
			onWsOpen: function(){
				console.log('Connected :)');
			},
			onWsError: function(err){
				console.log(err);
			},
			onWsMessage: function(data){
				var detail = JSON.parse(data.detail)
				var event = detail.Event;
				var map = detail.Map;

				var dir = this.eventDirection(event);

				if (!this.objects[event.Nick]) {
					this.addAnimatedEnemy(event.Nick, eventPosition.x, eventPosition.y);
				}

				var eventPosition = this.getSpritePosition(event.To);
				switch(event.Type){
					case "MOVE":
						this.objects[event.Nick].move(dir, eventPosition.x, eventPosition.y);
						break;
					case "JOIN":
						this.objects[event.Nick].stand();
						break;
					case "DEAD":
						var player = this.objects[event.Nick];
						this.stage.removeChild(player.standing);
						this.objects[event.Nick].remove(this.stage);
						delete this.objects[event.Nick];
						break;
					case "ATTACK":
						this.objects[event.Nick].attack(dir);
						break;
					case "SPELL":
						this.objects[event.Nick].spell(dir);
						break;
				}
				this.displayMap(map);
			},
			scale: function(factor) {
				this.stage.scale.x = factor;
				this.stage.scale.y = factor;
			},
			// abs takes a position coming from the battle server which could be negative and makes it positive assuming a map size of 256 squared.
			abs: function(pos) {
				return {x: p.x + 0xff, y: y + 0xff};
			},
			displayMap: function(map){
				var gameObjects = map.gameObjects;
				var players = [];
				for(var i = 0; i < gameObjects.length; i++){
					var gameObject = gameObjects[i];
					if(gameObject.type != "HEALTH_FOUNTAIN"){
						players.push(gameObject);
						if(gameObject.nick != localStorage.username && this.objects[gameObject.nick] == undefined){
							var position = this.getSpritePosition(gameObject.position);
							this.addAnimatedEnemy(gameObject.nick, position.x, position.y);
							this.objects[gameObject.nick].stand();
						}
					}else if (!this.objects['health_fountain']){
							var position = this.getSpritePosition(gameObject.position);
							var hf = this.newHealthFountain(position.x, position.y);
							this.objects['health_fountain'] = hf;
							this.stage.addChild(hf);
					}
				}
				this.players = players;
			},
			// direction computes the direction of something that goes from a to b
			direction: function(a, b) {
				if (!a || isNaN(a.x) || isNaN(a.y) || !b || isNaN(b.x) || isNaN(b.y)) {
					console.log('Tried to compute direction of something that is not two positions.');
					return;
				}

				var diff = { x: b.x - a.x, y: b.y - a.y };

				if (Math.abs(diff.x) > Math.abs(diff.y)) {
					if (diff.x < 0) {
						return 'left';
					}
					return 'right';
				}
				if (diff.y < 0) {
					return 'up';
				}
				return 'down';
			},
			eventDirection: function(e) {
				if (!e || !e.From || !e.To) {
					console.log('Tried to compute event direction of something that is not a directed event!');
					return;
				}
				return direction(e.From, e.To);
			}
			moveAllObjects: function(direction) {
				var offset = {
					x: this.spriteSize * (direction === 'left' ? -1 : 1),
					y: this.spriteSize * (direction === 'down' ? 1 : -1)
				};

				for (var key in this.objects) {
					this.objects[key].increasePosition(offset.x, offset.y);
				}
			},
			ready: function(){
				var that = this;
				document.onwheel = function(e) {
					that.scale(that.currentScale += (e.deltaY / screen.height));
				};
				var token = localStorage.token;
				this.wsUrl = 'ws://localhost:8090/?token=' + token;
				this.me = {};
				this.objects = {};
				var element = this;
				//Aliases
				var Container = PIXI.Stage,
						autoDetectRenderer = PIXI.autoDetectRenderer,
						loader = PIXI.loader,
						resources = PIXI.loader.resources,
						Sprite = PIXI.Sprite,
						TextureCache = PIXI.utils.TextureCache;

				var stage = new Container();
				var dimension = 840;
				this.dimension = dimension;
				var spriteSize = dimension / 22;
				this.spriteSize = spriteSize;
				var renderer = autoDetectRenderer(dimension, dimension);
				renderer.autoResize = true;
				this.stage = stage;
				this.$.battleView.appendChild(renderer.view);

				requestAnimationFrame(animate);
				loader
					.add('/images/health_fountain.png')
					.add('/images/sand.png')
					.add('/images/redhead.png')
					.load(setup);

				function setup(){
					var grassTexture = resources['/images/sand.png'].texture
					grassTexture.baseTexture.width = spriteSize;
					grassTexture.baseTexture.height = spriteSize;

					var ground = new PIXI.extras.TilingSprite(grassTexture, dimension * 2, dimension * 2);
					ground.position.x = 0;
					ground.position.y = 0;
					ground.tilePosition.x = 0;
					ground.tilePosition.y = 0;
					element.ground = ground;
					stage.addChild(element.ground);

					element.initializePlayer();
				}
				function animate(){
					requestAnimationFrame(animate);
					renderer.render(stage);
				}
			},
			newHealthFountain: function(x, y){
				var texture = PIXI.utils.TextureCache["/images/health_fountain.png"];
				var hf = new PIXI.Sprite(texture);
				hf.height = this.spriteSize;
				hf.width = this.spriteSize;
				hf.position.x = x;
				hf.position.y = y;
				hf.increasePosition = function(xo, yo){
					var xOffset = xo/100;
					var yOffset = yo/100;
					this.position.x = this.position.x + xOffset;
					this.position.y = this.position.y + yOffset;
					var that = this;
					var interval = setInterval(function(){
						var myx = that.position.x;
						var myy = that.position.y;
						that.position.x = that.position.x + xOffset;
						that.position.y = that.position.y + yOffset;
					}, 10)
					setTimeout(function(){
						clearInterval(interval);
					}, 1000);
				}
				hf.remove = function(stage){
					stage.removeChild(this);
				}
				return hf;
			},
			newPlayer: function(nick, x, y){
				var texture = PIXI.utils.TextureCache["/images/samurai.png"];
				var rectangle = new PIXI.Rectangle(1, 1, 40, 29);
				texture.frame = rectangle;
				var player = new PIXI.Sprite(texture);
				player.height = this.spriteSize;
				player.width = this.spriteSize;
				player.anchor.x = 0;
				player.anchor.y = 0;
				player.position.x = x * this.spriteSize;
				player.position.y = y * this.spriteSize;
				this.objects[nick] = player;
			},
			initializePlayer: function(){
				this.animatedPlayer = this.$.playerService.getAnimatedPlayer(this.dimension/2, this.dimension/2, 2 * this.spriteSize);
				this.animatedPlayer.addToStage(this.stage);

				var element = this;
				this.animatedPlayer.move = function(direction){
					for(var key in this.attacking){
						this.attacking[key].visible = false;
						this.moving[key].visible = false;
						this.casting[key].visible = false;
					}
					this.standing.visible = false;
					this.moving[direction].visible = true;
					this.moving[direction].play();
					var that = this;
					var interval = setInterval(function(){
						var value = 0.5;
						switch(direction){
							case 'left':
								element.ground.tilePosition.x += value;
								break;
							case 'up':
								element.ground.tilePosition.y += value;
								break;
							case 'down':
								element.ground.tilePosition.y -= value;
								break;
							case 'right':
								element.ground.tilePosition.x -= value;
								break;
						}
					}, 10)
					setTimeout(function(){
						that.stand();
						that.moving[direction].stop();
						clearInterval(interval);
					}, 1000);
				}
				this.animatedPlayer.attack = function(direction){
					this.standing.visible = false;
					for(var key in this.attacking){
						this.attacking[key].visible = false;
						this.moving[key].visible = false;
						this.casting[key].visible = false;
					}
					this.attacking[direction].visible = true;
					this.attacking[direction].play();
					var that = this;
					setTimeout(function(){
						that.stand();
						that.attacking[direction].stop();
					}, 500);
				}
				this.animatedPlayer.spell = function(direction){
					this.standing.visible = false;
					for(var key in this.attacking){
						this.attacking[key].visible = false;
						this.moving[key].visible = false;
						this.casting[key].visible = false;
					}
					this.casting[direction].visible = true;
					this.casting[direction].play();
					var that = this;
					setTimeout(function(){
						that.stand();
						that.casting[direction].stop();
					}, 500);
				}
				this.animatedPlayer.stand();
			},
			addAnimatedEnemy: function(nick, x, y){
				var animatedPlayer = this.$.playerService.getAnimatedPlayer(x, y, 2 * this.spriteSize);
				animatedPlayer.nick = new PIXI.Text(nick , {font:"15px Arial", fill:"green"});
				animatedPlayer.nick.position.x = x + 17;
				animatedPlayer.nick.position.y = y + 15;
				animatedPlayer.addToStage(this.stage);
				this.stage.addChild(animatedPlayer.nick);

				var element = this;
				animatedPlayer.remove = function(stage){
					for(var key in this.attacking){
						this.attacking[key].visible = false;
						this.moving[key].visible = false;
						this.casting[key].visible = false;
						stage.removeChild(this.attacking[key]);
						stage.removeChild(this.moving[key]);
						stage.removeChild(this.casting[key]);
					}
					this.standing.visible = false;
					stage.removeChild(this.standing);
					localStorage.username.visible = false;
					var stageId = stage.children.indexOf(localStorage.username);
					stage.removeChildAt(stageId);
				}
				animatedPlayer.move = function(direction, x, y){
					for(var key in this.attacking){
						this.attacking[key].visible = false;
						this.moving[key].visible = false;
						this.casting[key].visible = false;
					}
					this.standing.visible = false;
					this.moving[direction].visible = true;
					this.moving[direction].play();
					var that = this;
					var xOffset = (x - that.standing.position.x)/100;
					var yOffset = (y - that.standing.position.y)/100;

					var interval = setInterval(function(){
						var myx = that.standing.position.x;
						var myy = that.standing.position.y;
						that.setPosition(myx + xOffset, myy + yOffset);
					}, 10)
					setTimeout(function(){
						that.stand();
						that.moving[direction].stop();
						clearInterval(interval);
					}, 1000);
				}
				animatedPlayer.setPosition = function(x, y){
					for(var key in this.attacking){
						this.attacking[key].position.x = x;
						this.attacking[key].position.y = y;
						this.moving[key].position.x = x;
						this.moving[key].position.y = y;
						this.casting[key].position.x = x;
						this.casting[key].position.y = y;
					}
					this.standing.position.x = x;
					this.standing.position.y = y;
					localStorage.username.position.y = y + 15;
					localStorage.username.position.x = x + 17;
				}
				animatedPlayer.attack = function(direction){
					this.standing.visible = false;
					for(var key in this.attacking){
						this.attacking[key].visible = false;
						this.moving[key].visible = false;
						this.casting[key].visible = false;
					}
					this.attacking[direction].visible = true;
					this.attacking[direction].play();
					var that = this;
					setTimeout(function(){
						that.stand();
						that.attacking[direction].stop();
					}, 500);
				}
				animatedPlayer.spell = function(direction){
					this.standing.visible = false;
					for(var key in this.attacking){
						this.attacking[key].visible = false;
						this.moving[key].visible = false;
						this.casting[key].visible = false;
					}
					this.casting[direction].visible = true;
					this.casting[direction].play();
					var that = this;
					setTimeout(function(){
						that.stand();
						that.casting[direction].stop();
					}, 500);
				}
				animatedPlayer.increasePosition = function(xo, yo){
					var xOffset = xo/100;
					var yOffset = yo/100;
					this.setPosition(this.standing.position.x + xOffset, this.standing.position.y + yOffset);
					var that = this;
					var interval = setInterval(function() {
						var myx = that.standing.position.x;
						var myy = that.standing.position.y;
						that.setPosition(myx + xOffset, myy + yOffset);
					}, 10)
					setTimeout(function() {
						clearInterval(interval);
					}, 1000);
				}
				this.objects[nick] = animatedPlayer;
				animatedPlayer.stand();
			}
		});
	</script>
</dom-module>
